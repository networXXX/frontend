/**
 * network
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 2017-02-05T01:28:32Z
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { ActivateUserRequest } from '../model/activateUserRequest';
import { ChangePasswordRequest } from '../model/changePasswordRequest';
import { FogotPasswordRequest } from '../model/fogotPasswordRequest';
import { FriendResponse } from '../model/friendResponse';
import { InsertFriendRequest } from '../model/insertFriendRequest';
import { LoginUserRequest } from '../model/loginUserRequest';
import { LoginUserResponse } from '../model/loginUserResponse';
import { LoginWithTokenRequest } from '../model/loginWithTokenRequest';
import { LogoutRequest } from '../model/logoutRequest';
import { LogoutResponse } from '../model/logoutResponse';
import { RegisterUserRequest } from '../model/registerUserRequest';
import { RegisterUserResponse } from '../model/registerUserResponse';
import { RequestFriendRequest } from '../model/requestFriendRequest';
import { SearchFriendResponse } from '../model/searchFriendResponse';
import { SearchUserResponse } from '../model/searchUserResponse';
import { UpdateFriendRequest } from '../model/updateFriendRequest';
import { UpdateUserRequest } from '../model/updateUserRequest';
import { UserResponse } from '../model/userResponse';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class DefaultService {

    protected basePath = 'https://9csrrzydk8.execute-api.us-east-1.amazonaws.com/dev';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * 
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public activateOptions(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public activateOptions(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public activateOptions(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public activateOptions(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.options<any>(`${this.basePath}/activate`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param activateUserRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public activatePost(activateUserRequest: ActivateUserRequest, observe?: 'body', reportProgress?: boolean): Observable<UserResponse>;
    public activatePost(activateUserRequest: ActivateUserRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UserResponse>>;
    public activatePost(activateUserRequest: ActivateUserRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UserResponse>>;
    public activatePost(activateUserRequest: ActivateUserRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (activateUserRequest === null || activateUserRequest === undefined) {
            throw new Error('Required parameter activateUserRequest was null or undefined when calling activatePost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<UserResponse>(`${this.basePath}/activate`,
            activateUserRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public friendsConfirmOptions(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public friendsConfirmOptions(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public friendsConfirmOptions(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public friendsConfirmOptions(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.options<any>(`${this.basePath}/friends/confirm`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param requestFriendRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public friendsConfirmPost(requestFriendRequest: RequestFriendRequest, observe?: 'body', reportProgress?: boolean): Observable<FriendResponse>;
    public friendsConfirmPost(requestFriendRequest: RequestFriendRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FriendResponse>>;
    public friendsConfirmPost(requestFriendRequest: RequestFriendRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FriendResponse>>;
    public friendsConfirmPost(requestFriendRequest: RequestFriendRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (requestFriendRequest === null || requestFriendRequest === undefined) {
            throw new Error('Required parameter requestFriendRequest was null or undefined when calling friendsConfirmPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<FriendResponse>(`${this.basePath}/friends/confirm`,
            requestFriendRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public friendsIdDelete(id: string, observe?: 'body', reportProgress?: boolean): Observable<FriendResponse>;
    public friendsIdDelete(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FriendResponse>>;
    public friendsIdDelete(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FriendResponse>>;
    public friendsIdDelete(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling friendsIdDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (networkAuthorizer) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.delete<FriendResponse>(`${this.basePath}/friends/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public friendsIdGet(id: string, observe?: 'body', reportProgress?: boolean): Observable<FriendResponse>;
    public friendsIdGet(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FriendResponse>>;
    public friendsIdGet(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FriendResponse>>;
    public friendsIdGet(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling friendsIdGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (networkAuthorizer) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<FriendResponse>(`${this.basePath}/friends/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public friendsIdOptions(id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public friendsIdOptions(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public friendsIdOptions(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public friendsIdOptions(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling friendsIdOptions.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.options<any>(`${this.basePath}/friends/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param id 
     * @param updateFriendRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public friendsIdPut(id: string, updateFriendRequest: UpdateFriendRequest, observe?: 'body', reportProgress?: boolean): Observable<FriendResponse>;
    public friendsIdPut(id: string, updateFriendRequest: UpdateFriendRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FriendResponse>>;
    public friendsIdPut(id: string, updateFriendRequest: UpdateFriendRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FriendResponse>>;
    public friendsIdPut(id: string, updateFriendRequest: UpdateFriendRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling friendsIdPut.');
        }
        if (updateFriendRequest === null || updateFriendRequest === undefined) {
            throw new Error('Required parameter updateFriendRequest was null or undefined when calling friendsIdPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (networkAuthorizer) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<FriendResponse>(`${this.basePath}/friends/${encodeURIComponent(String(id))}`,
            updateFriendRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public friendsOptions(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public friendsOptions(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public friendsOptions(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public friendsOptions(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.options<any>(`${this.basePath}/friends`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param insertFriendRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public friendsPost(insertFriendRequest: InsertFriendRequest, observe?: 'body', reportProgress?: boolean): Observable<FriendResponse>;
    public friendsPost(insertFriendRequest: InsertFriendRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FriendResponse>>;
    public friendsPost(insertFriendRequest: InsertFriendRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FriendResponse>>;
    public friendsPost(insertFriendRequest: InsertFriendRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (insertFriendRequest === null || insertFriendRequest === undefined) {
            throw new Error('Required parameter insertFriendRequest was null or undefined when calling friendsPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<FriendResponse>(`${this.basePath}/friends`,
            insertFriendRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public friendsRequestOptions(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public friendsRequestOptions(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public friendsRequestOptions(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public friendsRequestOptions(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.options<any>(`${this.basePath}/friends/request`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param requestFriendRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public friendsRequestPost(requestFriendRequest: RequestFriendRequest, observe?: 'body', reportProgress?: boolean): Observable<FriendResponse>;
    public friendsRequestPost(requestFriendRequest: RequestFriendRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FriendResponse>>;
    public friendsRequestPost(requestFriendRequest: RequestFriendRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FriendResponse>>;
    public friendsRequestPost(requestFriendRequest: RequestFriendRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (requestFriendRequest === null || requestFriendRequest === undefined) {
            throw new Error('Required parameter requestFriendRequest was null or undefined when calling friendsRequestPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<FriendResponse>(`${this.basePath}/friends/request`,
            requestFriendRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param query 
     * @param limit 
     * @param cursor 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public friendsSearchGet(query: string, limit: string, cursor?: string, observe?: 'body', reportProgress?: boolean): Observable<SearchFriendResponse>;
    public friendsSearchGet(query: string, limit: string, cursor?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SearchFriendResponse>>;
    public friendsSearchGet(query: string, limit: string, cursor?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SearchFriendResponse>>;
    public friendsSearchGet(query: string, limit: string, cursor?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (query === null || query === undefined) {
            throw new Error('Required parameter query was null or undefined when calling friendsSearchGet.');
        }
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling friendsSearchGet.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (query !== undefined) {
            queryParameters = queryParameters.set('query', <any>query);
        }
        if (cursor !== undefined) {
            queryParameters = queryParameters.set('cursor', <any>cursor);
        }
        if (limit !== undefined) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;

        // authentication (networkAuthorizer) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<SearchFriendResponse>(`${this.basePath}/friends/search`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public friendsSearchOptions(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public friendsSearchOptions(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public friendsSearchOptions(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public friendsSearchOptions(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.options<any>(`${this.basePath}/friends/search`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public friendsUnfriendOptions(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public friendsUnfriendOptions(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public friendsUnfriendOptions(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public friendsUnfriendOptions(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.options<any>(`${this.basePath}/friends/unfriend`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param requestFriendRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public friendsUnfriendPost(requestFriendRequest: RequestFriendRequest, observe?: 'body', reportProgress?: boolean): Observable<FriendResponse>;
    public friendsUnfriendPost(requestFriendRequest: RequestFriendRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FriendResponse>>;
    public friendsUnfriendPost(requestFriendRequest: RequestFriendRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FriendResponse>>;
    public friendsUnfriendPost(requestFriendRequest: RequestFriendRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (requestFriendRequest === null || requestFriendRequest === undefined) {
            throw new Error('Required parameter requestFriendRequest was null or undefined when calling friendsUnfriendPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<FriendResponse>(`${this.basePath}/friends/unfriend`,
            requestFriendRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public loginOptions(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public loginOptions(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public loginOptions(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public loginOptions(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.options<any>(`${this.basePath}/login`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param loginUserRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public loginPost(loginUserRequest: LoginUserRequest, observe?: 'body', reportProgress?: boolean): Observable<LoginUserResponse>;
    public loginPost(loginUserRequest: LoginUserRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<LoginUserResponse>>;
    public loginPost(loginUserRequest: LoginUserRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<LoginUserResponse>>;
    public loginPost(loginUserRequest: LoginUserRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (loginUserRequest === null || loginUserRequest === undefined) {
            throw new Error('Required parameter loginUserRequest was null or undefined when calling loginPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<LoginUserResponse>(`${this.basePath}/login`,
            loginUserRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public logoutOptions(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public logoutOptions(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public logoutOptions(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public logoutOptions(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.options<any>(`${this.basePath}/logout`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param logoutRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public logoutPost(logoutRequest: LogoutRequest, observe?: 'body', reportProgress?: boolean): Observable<LogoutResponse>;
    public logoutPost(logoutRequest: LogoutRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<LogoutResponse>>;
    public logoutPost(logoutRequest: LogoutRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<LogoutResponse>>;
    public logoutPost(logoutRequest: LogoutRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (logoutRequest === null || logoutRequest === undefined) {
            throw new Error('Required parameter logoutRequest was null or undefined when calling logoutPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (networkAuthorizer) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<LogoutResponse>(`${this.basePath}/logout`,
            logoutRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public registerOptions(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public registerOptions(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public registerOptions(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public registerOptions(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.options<any>(`${this.basePath}/register`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param registerUserRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public registerPost(registerUserRequest: RegisterUserRequest, observe?: 'body', reportProgress?: boolean): Observable<RegisterUserResponse>;
    public registerPost(registerUserRequest: RegisterUserRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RegisterUserResponse>>;
    public registerPost(registerUserRequest: RegisterUserRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RegisterUserResponse>>;
    public registerPost(registerUserRequest: RegisterUserRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (registerUserRequest === null || registerUserRequest === undefined) {
            throw new Error('Required parameter registerUserRequest was null or undefined when calling registerPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<RegisterUserResponse>(`${this.basePath}/register`,
            registerUserRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersChangepasswordOptions(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public usersChangepasswordOptions(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public usersChangepasswordOptions(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public usersChangepasswordOptions(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.options<any>(`${this.basePath}/users/changepassword`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param changePasswordRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersChangepasswordPost(changePasswordRequest: ChangePasswordRequest, observe?: 'body', reportProgress?: boolean): Observable<LoginUserResponse>;
    public usersChangepasswordPost(changePasswordRequest: ChangePasswordRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<LoginUserResponse>>;
    public usersChangepasswordPost(changePasswordRequest: ChangePasswordRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<LoginUserResponse>>;
    public usersChangepasswordPost(changePasswordRequest: ChangePasswordRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (changePasswordRequest === null || changePasswordRequest === undefined) {
            throw new Error('Required parameter changePasswordRequest was null or undefined when calling usersChangepasswordPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (networkAuthorizer) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<LoginUserResponse>(`${this.basePath}/users/changepassword`,
            changePasswordRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersForgetpasswordOptions(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public usersForgetpasswordOptions(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public usersForgetpasswordOptions(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public usersForgetpasswordOptions(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.options<any>(`${this.basePath}/users/forgetpassword`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param fogotPasswordRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersForgetpasswordPost(fogotPasswordRequest: FogotPasswordRequest, observe?: 'body', reportProgress?: boolean): Observable<UserResponse>;
    public usersForgetpasswordPost(fogotPasswordRequest: FogotPasswordRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UserResponse>>;
    public usersForgetpasswordPost(fogotPasswordRequest: FogotPasswordRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UserResponse>>;
    public usersForgetpasswordPost(fogotPasswordRequest: FogotPasswordRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (fogotPasswordRequest === null || fogotPasswordRequest === undefined) {
            throw new Error('Required parameter fogotPasswordRequest was null or undefined when calling usersForgetpasswordPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<UserResponse>(`${this.basePath}/users/forgetpassword`,
            fogotPasswordRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersIdDelete(id: string, observe?: 'body', reportProgress?: boolean): Observable<UserResponse>;
    public usersIdDelete(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UserResponse>>;
    public usersIdDelete(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UserResponse>>;
    public usersIdDelete(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling usersIdDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (networkAuthorizer) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.delete<UserResponse>(`${this.basePath}/users/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersIdGet(id: string, observe?: 'body', reportProgress?: boolean): Observable<UserResponse>;
    public usersIdGet(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UserResponse>>;
    public usersIdGet(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UserResponse>>;
    public usersIdGet(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling usersIdGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (networkAuthorizer) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<UserResponse>(`${this.basePath}/users/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersIdOptions(id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public usersIdOptions(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public usersIdOptions(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public usersIdOptions(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling usersIdOptions.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.options<any>(`${this.basePath}/users/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param id 
     * @param updateUserRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersIdPut(id: string, updateUserRequest: UpdateUserRequest, observe?: 'body', reportProgress?: boolean): Observable<UserResponse>;
    public usersIdPut(id: string, updateUserRequest: UpdateUserRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UserResponse>>;
    public usersIdPut(id: string, updateUserRequest: UpdateUserRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UserResponse>>;
    public usersIdPut(id: string, updateUserRequest: UpdateUserRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling usersIdPut.');
        }
        if (updateUserRequest === null || updateUserRequest === undefined) {
            throw new Error('Required parameter updateUserRequest was null or undefined when calling usersIdPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (networkAuthorizer) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<UserResponse>(`${this.basePath}/users/${encodeURIComponent(String(id))}`,
            updateUserRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersLoginwithfacebookOptions(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public usersLoginwithfacebookOptions(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public usersLoginwithfacebookOptions(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public usersLoginwithfacebookOptions(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.options<any>(`${this.basePath}/users/loginwithfacebook`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param loginWithTokenRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersLoginwithfacebookPost(loginWithTokenRequest: LoginWithTokenRequest, observe?: 'body', reportProgress?: boolean): Observable<LoginUserResponse>;
    public usersLoginwithfacebookPost(loginWithTokenRequest: LoginWithTokenRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<LoginUserResponse>>;
    public usersLoginwithfacebookPost(loginWithTokenRequest: LoginWithTokenRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<LoginUserResponse>>;
    public usersLoginwithfacebookPost(loginWithTokenRequest: LoginWithTokenRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (loginWithTokenRequest === null || loginWithTokenRequest === undefined) {
            throw new Error('Required parameter loginWithTokenRequest was null or undefined when calling usersLoginwithfacebookPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<LoginUserResponse>(`${this.basePath}/users/loginwithfacebook`,
            loginWithTokenRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersLoginwithgoogleOptions(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public usersLoginwithgoogleOptions(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public usersLoginwithgoogleOptions(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public usersLoginwithgoogleOptions(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.options<any>(`${this.basePath}/users/loginwithgoogle`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param loginWithTokenRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersLoginwithgooglePost(loginWithTokenRequest: LoginWithTokenRequest, observe?: 'body', reportProgress?: boolean): Observable<LoginUserResponse>;
    public usersLoginwithgooglePost(loginWithTokenRequest: LoginWithTokenRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<LoginUserResponse>>;
    public usersLoginwithgooglePost(loginWithTokenRequest: LoginWithTokenRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<LoginUserResponse>>;
    public usersLoginwithgooglePost(loginWithTokenRequest: LoginWithTokenRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (loginWithTokenRequest === null || loginWithTokenRequest === undefined) {
            throw new Error('Required parameter loginWithTokenRequest was null or undefined when calling usersLoginwithgooglePost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<LoginUserResponse>(`${this.basePath}/users/loginwithgoogle`,
            loginWithTokenRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param query 
     * @param limit 
     * @param cursor 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersSearchGet(query: string, limit: string, cursor?: string, observe?: 'body', reportProgress?: boolean): Observable<SearchUserResponse>;
    public usersSearchGet(query: string, limit: string, cursor?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SearchUserResponse>>;
    public usersSearchGet(query: string, limit: string, cursor?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SearchUserResponse>>;
    public usersSearchGet(query: string, limit: string, cursor?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (query === null || query === undefined) {
            throw new Error('Required parameter query was null or undefined when calling usersSearchGet.');
        }
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling usersSearchGet.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (query !== undefined) {
            queryParameters = queryParameters.set('query', <any>query);
        }
        if (cursor !== undefined) {
            queryParameters = queryParameters.set('cursor', <any>cursor);
        }
        if (limit !== undefined) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;

        // authentication (networkAuthorizer) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<SearchUserResponse>(`${this.basePath}/users/search`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersSearchOptions(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public usersSearchOptions(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public usersSearchOptions(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public usersSearchOptions(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.options<any>(`${this.basePath}/users/search`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
